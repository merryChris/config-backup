syntax enable
syntax on
set cindent
set nu
set fo=trocq
set hlsearch
set incsearch
set ignorecase smartcase
set backspace=start
set showcmd
set ruler
set mouse=v

set shiftwidth=2
set tabstop=2
set expandtab

map <F4> Wi<CR><ESC>
map <C-j> <C-W>j<C-W>_
map <C-k> <C-W>k<C-W>_
map <C-l> <C-W>_
filetype plugin on
filetype indent on

colorscheme desert

highlight MBEVisibleNormal guibg=LightGray guifg=DarkGray
highlight MBEChanged guibg=Red guifg=DarkRed
highlight MBENormal term=bold cterm=bold gui=bold guibg=Gray guifg=Black
highlight MBEVisibleChanged term=bold cterm=bold gui=bold guibg=DarkRed guifg=Black

" use Alt+; add comment,like emacs
autocmd filetype cpp,java map <Esc>; $a<tab><tab>//
autocmd filetype cpp,java imap <Esc>; <End><tab><tab>//
autocmd filetype c map <Esc>; $a<tab><tab>/*  */<Esc>2hi
autocmd filetype c imap <Esc>; <End><tab><tab>/*  */<Left><Left><Left>
autocmd filetype sh map <Esc>; O#

" " use Alt+' comment current line
autocmd filetype cpp,java map <Esc>' ^i//<Esc>
autocmd filetype cpp,java imap <Esc>' <C-O>^//
autocmd filetype c map <Esc>' ^i/* <C-O>$ */<Esc>
autocmd filetype c imap <Esc>' <C-O>^/* <C-O>$ */
autocmd filetype sh map <Esc>' ^i#<Esc>
autocmd filetype sh imap <Esc>' <C-O>^#

" Open quickfix window
map <F9> :call QuickFixWin()<CR>

let s:bQuick=0
function! QuickFixWin()
  if s:bQuick==0
    let s:bQuick=1
    copen
  elseif s:bQuick==1
    let s:bQuick=0
    cclose
  endif
endfunction

" use Ctrl+x+[l|n|p|cc] to list|next|previous|jump to count the result
map <C-x>l <ESC>:cl<ENTER>
map <C-x>n <ESC>:cn<ENTER>
map <C-x>p <ESC>:cp<ENTER>
map <C-x>c <ESC>:cc
map <C-y> <ESC>:w<ENTER>
:inoremap <C-y> <ESC>:w<ENTER>

" For Ruby
autocmd filetype ruby source ~/.vim/ruby-macros.vim

command! -nargs=1 -bang -complete=custom,<SID>PathComplete FindInPath
      \ :find<bang> <args>
function! s:PathComplete(ArgLead, CmdLine, CursorPos)
  return UserFileComplete(a:ArgLead, a:CmdLine, a:CursorPos, 1, &path)
endfunction

" For Python
autocmd filetype python source ~/.vim/python-macros.vim
autocmd filetype python set shiftwidth=4
autocmd filetype python set tabstop=4

map \s :!./sync_tous.sh<CR>
map \c :%!xxd -r<CR>
map \h :%!xxd<CR>
map \m :!ruby script/custom/min<CR>

" For JavaScript
let g:tlist_javascript_settings = 'javascript;s:string;a:array;o:object;f:function;m:member'

" For HTML
au BufNewFile,BufRead *.jst,*.hbs,*.erb set filetype=html

" autocmd FileType ruby autocmd BufWritePre <buffer> :%s/\s\+$//e
set list listchars=tab:»·,trail:·

" For plugins
autocmd vimenter * if !argc() | NERDTree | endif
map <C-n> :NERDTreeToggle<CR>
map <C-n> :NERDTreeFind<CR>
map <C-g> :GitGutterLineHighlightsToggle<CR>
map <C-t> :TlistToggle<CR>
map <C-z> :BufExplorerHorizontalSplit<CR>

let NERDTreeHighlightCursorline=1
let gitgutter_enabled=1
let Tlist_GainFocus_On_ToggleOpen=1
let Tlist_Show_One_File=1
let Tlist_Exit_OnlyWindow=1
let Tlist_Use_Right_Window=1
let g:bufExplorerSplitBelow=1

let g:miniBufExplMapWindowNavVim = 1
let g:miniBufExplMapWindowNavArrows = 1
let g:miniBufExplMapCTabSwitchBufs = 1
let g:miniBufExplModSelTarget = 1

let g:xptemplate_key = '<Tab>'

" For fcitx
let g:input_toggle = 1
"function! Fcitx2en()
"  let s:input_status = system("fcitx-remote")
"  if s:input_status == 2
"     let g:input_toggle = 1
"     let l:a = system("fcitx-remote -c")
"  endif
"endfunction

"function! Fcitx2zh()
"  let s:input_status = system("fcitx-remote")
"  if s:input_status != 2 && g:input_toggle == 1
"     let l:a = system("fcitx-remote -o")
"     let g:input_toggle = 0
"  endif
"endfunction

set timeoutlen=150
autocmd InsertLeave * call Fcitx2en()
" autocmd InsertEnter * call Fcitx2zh()
